# docker-compose.production.yml
version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: stockalert-db
    environment:
      POSTGRES_DB: stockalert
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256 --auth-local=scram-sha-256"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - stockalert-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: stockalert-redis
    command: redis-server --requirepass ${REDIS_PASSWORD} --maxmemory 256mb --maxmemory-policy allkeys-lru
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - stockalert-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Backend API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.production
    container_name: stockalert-api
    environment:
      - ENVIRONMENT=production
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/stockalert
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - JWT_SECRET_KEY=${JWT_SECRET_KEY}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
      - FIREBASE_CONFIG=${FIREBASE_CONFIG}
      - NEWSAPI_KEY=${NEWSAPI_KEY}
    volumes:
      - ./backend:/app
      - ./logs:/app/logs
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - stockalert-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: stockalert-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./ssl:/etc/nginx/ssl:ro
      - nginx_cache:/var/cache/nginx
    depends_on:
      - backend
    networks:
      - stockalert-network
    restart: unless-stopped

  # Prometheus Monitoring
  prometheus:
    image: prom/prometheus:latest
    container_name: stockalert-prometheus
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    ports:
      - "9090:9090"
    networks:
      - stockalert-network
    restart: unless-stopped

  # Grafana Dashboard
  grafana:
    image: grafana/grafana:latest
    container_name: stockalert-grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
      - GF_INSTALL_PLUGINS=redis-datasource
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
    ports:
      - "3000:3000"
    depends_on:
      - prometheus
    networks:
      - stockalert-network
    restart: unless-stopped

  # Background Worker for Monitoring
  worker:
    build:
      context: ./backend
      dockerfile: Dockerfile.production
    container_name: stockalert-worker
    command: python monitor.py
    environment:
      - ENVIRONMENT=production
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/stockalert
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - FIREBASE_CONFIG=${FIREBASE_CONFIG}
    depends_on:
      - postgres
      - redis
    networks:
      - stockalert-network
    restart: unless-stopped

  # Backup Service
  backup:
    image: postgres:15-alpine
    container_name: stockalert-backup
    environment:
      - PGPASSWORD=${DB_PASSWORD}
    volumes:
      - ./backups:/backups
    command: >
      sh -c "while true; do
        pg_dump -h postgres -U ${DB_USER} stockalert > /backups/backup_$$(date +%Y%m%d_%H%M%S).sql;
        find /backups -name 'backup_*.sql' -mtime +7 -delete;
        sleep 86400;
      done"
    depends_on:
      - postgres
    networks:
      - stockalert-network
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:
  nginx_cache:

networks:
  stockalert-network:
    driver: bridge

---
# .github/workflows/ci-cd.yml - GitHub Actions CI/CD Pipeline
name: StockAlert Pro CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [created]

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security Scanning
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Run Snyk Security Scan
        uses: snyk/actions/python@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

  # Backend Tests
  test-backend:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: stockalert_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio black flake8 mypy
      
      - name: Run linting
        run: |
          cd backend
          black --check .
          flake8 . --max-line-length=120
          mypy . --ignore-missing-imports
      
      - name: Run tests with coverage
        env:
          DATABASE_URL: postgresql://postgres:testpass@localhost:5432/stockalert_test
          REDIS_HOST: localhost
          JWT_SECRET_KEY: test-secret-key
          ENVIRONMENT: test
        run: |
          cd backend
          pytest tests/ -v --cov=. --cov-report=xml --cov-report=html
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml
          flags: backend
          name: backend-coverage

  # Flutter App Tests
  test-flutter:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.16.0'
          channel: 'stable'
      
      - name: Install dependencies
        run: |
          cd mobile
          flutter pub get
      
      - name: Run Flutter analyze
        run: |
          cd mobile
          flutter analyze
      
      - name: Run Flutter tests
        run: |
          cd mobile
          flutter test --coverage
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./mobile/coverage/lcov.info
          flags: flutter
          name: flutter-coverage

  # Build Docker Images
  build-docker:
    needs: [security-scan, test-backend]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile.production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  # Build Flutter Apps
  build-flutter:
    needs: [test-flutter]
    runs-on: ${{ matrix.os }}
    if: github.event_name == 'release'
    
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        include:
          - os: ubuntu-latest
            platform: android
            artifact: apk
          - os: macos-latest
            platform: ios
            artifact: ipa
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.16.0'
          channel: 'stable'
      
      - name: Setup Java (Android only)
        if: matrix.platform == 'android'
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
      
      - name: Build Android APK
        if: matrix.platform == 'android'
        run: |
          cd mobile
          flutter build apk --release
          flutter build appbundle --release
      
      - name: Build iOS IPA
        if: matrix.platform == 'ios'
        run: |
          cd mobile
          flutter build ios --release --no-codesign
          cd ios
          xcodebuild -workspace Runner.xcworkspace -scheme Runner -sdk iphoneos -configuration Release archive -archivePath $PWD/build/Runner.xcarchive
          xcodebuild -exportArchive -archivePath $PWD/build/Runner.xcarchive -exportOptionsPlist exportOptions.plist -exportPath $PWD/build/
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: ${{ matrix.platform }}-build
          path: |
            mobile/build/app/outputs/flutter-apk/*.apk
            mobile/build/app/outputs/bundle/release/*.aab
            mobile/ios/build/*.ipa

  # Deploy to Staging
  deploy-staging:
    needs: [build-docker]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Staging Server
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/stockalert
            git pull origin develop
            docker-compose -f docker-compose.production.yml pull
            docker-compose -f docker-compose.production.yml up -d --force-recreate
            docker-compose -f docker-compose.production.yml exec -T backend alembic upgrade head
      
      - name: Run Smoke Tests
        run: |
          sleep 30
          curl -f https://staging-api.stockalertpro.com/health || exit 1
      
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Staging deployment completed'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # Deploy to Production
  deploy-production:
    needs: [build-docker]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Production Servers
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.PRODUCTION_HOSTS }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/stockalert
            
            # Backup database before deployment
            docker-compose -f docker-compose.production.yml exec -T postgres pg_dump -U stockalert stockalert > /backups/pre-deploy-$(date +%Y%m%d_%H%M%S).sql
            
            # Blue-Green Deployment
            docker-compose -f docker-compose.production.yml pull
            docker-compose -f docker-compose.blue-green.yml up -d --no-deps --scale backend=2 backend
            
            # Wait for new containers to be healthy
            sleep 30
            
            # Switch traffic to new containers
            docker-compose -f docker-compose.production.yml exec -T nginx nginx -s reload
            
            # Remove old containers
            docker-compose -f docker-compose.production.yml up -d --remove-orphans
            
            # Run migrations
            docker-compose -f docker-compose.production.yml exec -T backend alembic upgrade head
      
      - name: Health Check
        run: |
          for i in {1..10}; do
            if curl -f https://api.stockalertpro.com/health; then
              echo "Health check passed"
              break
            fi
            echo "Health check attempt $i failed, retrying..."
            sleep 10
          done
      
      - name: Run E2E Tests
        run: |
          cd tests/e2e
          npm install
          npm run test:production
      
      - name: Rollback on Failure
        if: failure()
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.PRODUCTION_HOSTS }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/stockalert
            docker-compose -f docker-compose.production.yml down
            docker-compose -f docker-compose.production.yml up -d --force-recreate
      
      - name: Create Release Notes
        if: success()
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Release v${{ github.run_number }}
          draft: false
          prerelease: false
      
      - name: Notify Team
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow

---
# kubernetes/deployment.yaml - Kubernetes Deployment (Alternative to Docker Compose)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: stockalert-backend
  namespace: stockalert
spec:
  replicas: 3
  selector:
    matchLabels:
      app: stockalert-backend
  template:
    metadata:
      labels:
        app: stockalert-backend
    spec:
      containers:
      - name: backend
        image: ghcr.io/yourusername/stockalert:latest
        ports:
        - containerPort: 8000
        env:
        - name: ENVIRONMENT
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: stockalert-secrets
              key: database-url
        - name: JWT_SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: stockalert-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: stockalert-backend-service
  namespace: stockalert
spec:
  selector:
    app: stockalert-backend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8000
  type: LoadBalancer

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: stockalert-backend-hpa
  namespace: stockalert
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: stockalert-backend
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

---
# terraform/infrastructure.tf - Infrastructure as Code
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  
  backend "s3" {
    bucket = "stockalert-terraform-state"
    key    = "production/terraform.tfstate"
    region = "us-east-1"
    encrypt = true
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC Configuration
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Name = "stockalert-vpc"
    Environment = var.environment
  }
}

# Subnets
resource "aws_subnet" "public" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 1}.0/24"
  availability_zone = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true
  
  tags = {
    Name = "stockalert-public-${count.index + 1}"
    Type = "public"
  }
}

resource "aws_subnet" "private" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 10}.0/24"
  availability_zone = data.aws_availability_zones.available.names[count.index]
  
  tags = {
    Name = "stockalert-private-${count.index + 1}"
    Type = "private"
  }
}

# RDS Database
resource "aws_db_instance" "postgres" {
  identifier     = "stockalert-db"
  engine         = "postgres"
  engine_version = "15.4"
  instance_class = var.db_instance_class
  
  allocated_storage     = 100
  storage_encrypted     = true
  storage_type         = "gp3"
  
  db_name  = "stockalert"
  username = var.db_username
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.database.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  backup_retention_period = 30
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  deletion_protection = true
  skip_final_snapshot = false
  
  tags = {
    Name = "stockalert-database"
    Environment = var.environment
  }
}

# ElastiCache Redis
resource "aws_elasticache_cluster" "redis" {
  cluster_id           = "stockalert-cache"
  engine              = "redis"
  node_type           = var.redis_node_type
  num_cache_nodes     = 1
  parameter_group_name = "default.redis7"
  port                = 6379
  
  subnet_group_name = aws_elasticache_subnet_group.main.name
  security_group_ids = [aws_security_group.redis.id]
  
  snapshot_retention_limit = 5
  snapshot_window         = "03:00-05:00"
  
  tags = {
    Name = "stockalert-redis"
    Environment = var.environment
  }
}

# ECS Cluster for Container Orchestration
resource "aws_ecs_cluster" "main" {
  name = "stockalert-cluster"
  
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
  
  tags = {
    Name = "stockalert-ecs"
    Environment = var.environment
  }
}

# Application Load Balancer
resource "aws_lb" "main" {
  name               = "stockalert-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets           = aws_subnet.public[*].id
  
  enable_deletion_protection = true
  enable_http2              = true
  
  tags = {
    Name = "stockalert-alb"
    Environment = var.environment
  }
}

# CloudWatch Alarms
resource "aws_cloudwatch_metric_alarm" "high_cpu" {
  alarm_name          = "stockalert-high-cpu"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name        = "CPUUtilization"
  namespace          = "AWS/ECS"
  period             = "300"
  statistic          = "Average"
  threshold          = "80"
  alarm_description  = "This metric monitors ECS CPU utilization"
  alarm_actions      = [aws_sns_topic.alerts.arn]
  
  dimensions = {
    ClusterName = aws_ecs_cluster.main.name
  }
}

# WAF for DDoS Protection
resource "aws_wafv2_web_acl" "main" {
  name  = "stockalert-waf"
  scope = "REGIONAL"
  
  default_action {
    allow {}
  }
  
  rule {
    name     = "RateLimitRule"
    priority = 1
    
    action {
      block {}
    }
    
    statement {
      rate_based_statement {
        limit              = 2000
        aggregate_key_type = "IP"
      }
    }
    
    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name               = "RateLimitRule"
      sampled_requests_enabled   = true
    }
  }
  
  tags = {
    Name = "stockalert-waf"
    Environment = var.environment
  }
}

# Backup Configuration
resource "aws_backup_plan" "main" {
  name = "stockalert-backup-plan"
  
  rule {
    rule_name         = "daily_backups"
    target_vault_name = aws_backup_vault.main.name
    schedule          = "cron(0 5 ? * * *)"
    
    lifecycle {
      delete_after = 30
    }
    
    recovery_point_tags = {
      Environment = var.environment
    }
  }
}

resource "aws_backup_vault" "main" {
  name = "stockalert-backup-vault"
  
  tags = {
    Name = "stockalert-backups"
    Environment = var.environment
  }
}

---
# scripts/deploy.sh - Deployment Script
#!/bin/bash
set -e

# Configuration
ENVIRONMENT=${1:-staging}
VERSION=${2:-latest}
ROLLBACK=${3:-false}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1"
    exit 1
}

warning() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1"
}

# Pre-deployment checks
pre_deploy_checks() {
    log "Running pre-deployment checks..."
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        error "Docker is not installed"
    fi
    
    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        error "Docker Compose is not installed"
    fi
    
    # Check environment file
    if [ ! -f ".env.$ENVIRONMENT" ]; then
        error "Environment file .env.$ENVIRONMENT not found"
    fi
    
    # Check SSL certificates
    if [ "$ENVIRONMENT" == "production" ]; then
        if [ ! -f "ssl/cert.pem" ] || [ ! -f "ssl/key.pem" ]; then
            error "SSL certificates not found"
        fi
    fi
    
    log "Pre-deployment checks passed"
}

# Backup database
backup_database() {
    log "Creating database backup..."
    
    BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).sql"
    
    docker-compose -f docker-compose.$ENVIRONMENT.yml exec -T postgres \
        pg_dump -U stockalert stockalert > "backups/$BACKUP_FILE"
    
    if [ $? -eq 0 ]; then
        log "Database backed up to backups/$BACKUP_FILE"
    else
        error "Database backup failed"
    fi
}

# Deploy application
deploy() {
    log "Starting deployment to $ENVIRONMENT..."
    
    # Load environment variables
    export $(cat .env.$ENVIRONMENT | xargs)
    
    # Pull latest images
    log "Pulling latest Docker images..."
    docker-compose -f docker-compose.$ENVIRONMENT.yml pull
    
    # Start services with zero-downtime deployment
    log "Starting services..."
    docker-compose -f docker-compose.$ENVIRONMENT.yml up -d --no-deps --scale backend=2 backend
    
    # Wait for services to be healthy
    log "Waiting for services to be healthy..."
    sleep 30
    
    # Run database migrations
    log "Running database migrations..."
    docker-compose -f docker-compose.$ENVIRONMENT.yml exec -T backend alembic upgrade head
    
    # Reload nginx
    log "Reloading nginx..."
    docker-compose -f docker-compose.$ENVIRONMENT.yml exec -T nginx nginx -s reload
    
    # Remove old containers
    log "Cleaning up old containers..."
    docker-compose -f docker-compose.$ENVIRONMENT.yml up -d --remove-orphans
    
    # Verify deployment
    verify_deployment
}

# Verify deployment
verify_deployment() {
    log "Verifying deployment..."
    
    # Check API health
    HEALTH_CHECK_URL="http://localhost:8000/health"
    if [ "$ENVIRONMENT" == "production" ]; then
        HEALTH_CHECK_URL="https://api.stockalertpro.com/health"
    fi
    
    for i in {1..10}; do
        if curl -f $HEALTH_CHECK_URL > /dev/null 2>&1; then
            log "Health check passed"
            break
        fi
        warning "Health check attempt $i failed, retrying..."
        sleep 5
    done
    
    # Check all services are running
    RUNNING_SERVICES=$(docker-compose -f docker-compose.$ENVIRONMENT.yml ps --services --filter "status=running" | wc -l)
    TOTAL_SERVICES=$(docker-compose -f docker-compose.$ENVIRONMENT.yml ps --services | wc -l)
    
    if [ "$RUNNING_SERVICES" -eq "$TOTAL_SERVICES" ]; then
        log "All services are running ($RUNNING_SERVICES/$TOTAL_SERVICES)"
    else
        error "Some services are not running ($RUNNING_SERVICES/$TOTAL_SERVICES)"
    fi
}

# Rollback deployment
rollback() {
    log "Starting rollback..."
    
    # Stop current containers
    docker-compose -f docker-compose.$ENVIRONMENT.yml down
    
    # Start previous version
    docker-compose -f docker-compose.$ENVIRONMENT.yml up -d
    
    log "Rollback completed"
}

# Send notification
send_notification() {
    STATUS=$1
    MESSAGE=$2
    
    # Send to Slack
    if [ ! -z "$SLACK_WEBHOOK" ]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"Deployment to $ENVIRONMENT $STATUS: $MESSAGE\"}" \
            $SLACK_WEBHOOK
    fi
    
    # Send email
    if [ ! -z "$NOTIFICATION_EMAIL" ]; then
        echo "$MESSAGE" | mail -s "StockAlert Deployment $STATUS" $NOTIFICATION_EMAIL
    fi
}

# Main execution
main() {
    log "Starting deployment process for $ENVIRONMENT environment"
    
    # Run pre-deployment checks
    pre_deploy_checks
    
    # Backup database (production only)
    if [ "$ENVIRONMENT" == "production" ]; then
        backup_database
    fi
    
    # Deploy or rollback
    if [ "$ROLLBACK" == "true" ]; then
        rollback
    else
        deploy
    fi
    
    # Send notification
    send_notification "SUCCESS" "Deployment to $ENVIRONMENT completed successfully"
    
    log "Deployment process completed successfully"
}

# Error handler
trap 'error "Deployment failed. Run with ROLLBACK=true to rollback."' ERR

# Run main function
main